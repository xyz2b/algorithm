package leetcode.p801;

class Solution {
    /**
     * 题目给定两个长度都为 n 的整型数组 nums1，nums2，每次操作我们可以交换 nums1 和 nums2 中相同位置上的数字。我们需要求使 nums1 和 nums2 严格递增的最小操作次数，题目保证题目用例可以实现操作。因为每次只能交换相同位置的两个数，所以位置 i 一定至少满足以下两种情况中的一种：
     * 1.nums1[i] > nums1[i−1] 且 nums2[i] > nums2[i−1]
     * 2.nums1[i] > nums2[i−1] 且 nums2[i] > nums1[i−1]
     * 否则无论是否交换 nums1[i] 和 nums2[i] 都不可能使数组 nums1 和 nums2 最终严格递增。
     *
     * 因为对于某一个位置来说只有交换和不交换两种情况，所以我们可以设 dp[i][0] 表示到位置 i 为止使数组 nums1 和 nums2 满足严格递增并且位置 i 不进行交换操作的最小操作数，设 dp[i][1] 表示到位置 i 为止使数组 nums1 和 nums2 满足严格递增并且位置 i 进行交换操作的最小操作数。我们思考如何求解各个状态：
     *
     * 1.当只满足上述的情况 1 而不满足情况 2 时，位置 i 的交换情况需要和位置 i − 1 的情况保持一致，即如果 i - 1 位置发生了交换，则 i 位置也需要交换，如果 i - 1 位置没有交换，则 i 位置也不需要交换（因为只满足 情况1 已经满足题目要求了，所以前一个元素没有交换后一个元素也不需要交换就可以满足题目要求，反之同理）：
     * dp[i][0]=dp[i−1][0]
     * dp[i][1]=dp[i−1][1]+1
     *
     * 2.当只满足上述的情况 2 而不满足情况 1 时，位置 i 的交换情况需要和位置 i − 1 的情况相反，即如果 i - 1 位置发生了交换，则 i 位置不需要交换，如果 i - 1 位置没有交换，则 i 位置就必须交换（因为只满足 情况2，不满足题目要求，所以前一个元素没有交换则后一个元素必须交换才能满足题目要求，反之同理）：
     * dp[i][0]=dp[i−1][1]
     * dp[i][1]=dp[i−1][0]+1
     *
     * 3.当同时满足上述的情况 1 和情况 2 时，dp[i][0]，dp[i][1] 取两种情况中的较小值即可：
     * dp[i][0]=min{dp[i−1][0],dp[i−1][1]}
     * dp[i][1]=min{dp[i−1][1],dp[i−1][0]}+1
     *
     * 上述的讨论是建立在 i > 0 的基础上的，而当 i = 0 时，无论是否交换都为合法状态，即可以初始化 dp[0][0]=0，dp[0][1]=1。又因为求解每一个状态都只与前一个状态有关，所以我们可以用「滚动数组」的方法来进行空间优化。
     * */
    public int minSwap(int[] nums1, int[] nums2) {
        int n = nums1.length;
        // a: dp[i][0]
        // b: dp[i][1]
        int a = 0, b = 1;
        for (int i = 1; i < n; i++) {
            // at: dp[i-1][0]
            // bt: dp[i-1][1]
            int at = a, bt = b;
            // 1.当只满足上述的情况 1 而不满足情况 2 时
            if ((nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) && !(nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]))  {
                a = at;
                b = bt + 1;
            }
            // 2.当只满足上述的情况 2 而不满足情况 1 时
            if (!(nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) && (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]))  {
                a = bt;
                b = at + 1;
            }
            // 3.当同时满足上述的情况 1 和情况 2 时
            if ((nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) && (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1])) {
                a = Math.min(at, bt);
                b = Math.min(at, bt) + 1;
            }
        }
        return Math.min(a, b);
    }
}
