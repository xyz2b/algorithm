package leetcode.p2972;

class Solution {
    public long incremovableSubarrayCount(int[] nums) {
        // 双指针
        // 删除一个子数组后，整个数组还剩下前后两部分，需要满足这两个部分都是严格递增，并且第一部分的最后一个元素小于第二个部分的第一个元素。
        // 1.先用左指针从前往后扫，直到一个前半部分不满足严格递增的位置，即nums[l] >= nums[l+1]，此时就可以得到l+2个答案，即可以通过删除子数组[l+1, r-1]、[l, r-1]、[l-1, r-1]、[0, r-1]得到严格递增的数组
        // 2.在用右指针从后往前扫，直到一个后半部分不满足严格递增的位置，即nums[r-1] >= nums[r]。
        //      期间如果nums[r] <= nums[l]，就把l往前移动（r之后包括r是严格递增的，l之前包括l是严格递增的，所以每次往前移动r时，l也往前移动时，遍历下一个r时l不需要回退），
        //      直到满足nums[r] > nums[l]即可，这样每次都和上面一样删除子数组[l+1, r-1]、[l, r-1]、[l-1, r-1]、[0, r-1]，可以获得l+2个答案
        int n = nums.length;
        long ret = 0;
        int l = 0;
        while (l < n-1) {
            if(nums[l] >= nums[l+1]) {
                break;
            }
            l++;
        }

        // 如果 l 等于最后一个元素，表示删除任意一个子数组即可，此时可直接计算答案。
        // 可以删除 n 个长度为 1的，n−1 个长度为 2 的... 1 个长度为 n 的子数组，一共有 n×(n+1)/2个子数组。
        if(l == n - 1) {
            return 1L * n * (n + 1) / 2;
        }

        ret += l + 2;
        for(int r = n - 1; r > 0; r--) {
            // 如果 r = n-1，即r是数组最后一个元素，此时后半部分是严格递增了，因为只有一个元素，只需要nums[r] > nums[l]就又可以得到l+2个答案
            // 所以这里后半部分的递增判断要略过只有最后一个元素的情况

            // 必须用r去比r+1，例如[6,5,7,8]，当r遍历到5的时候，如果不是用r去比r+1，而是r-1比r，那么r-1 6 就比 r 5大，就会跳出这个循环，就会漏考虑，删掉6的这种情况
            if(r < n - 1 && nums[r] >= nums[r+1]) {
                break;
            }

            while (l >= 0 && nums[r] <= nums[l]) {
                l--;
            }
            ret += l + 2;
        }
        return ret;
    }
}

